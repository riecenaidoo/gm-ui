article.tile {
  /* Each tile is self-contained, which is represented best as an article. */
  aspect-ratio: 4/4.75;
  border-radius: 0.5rem;
  display: grid;

  /* The shape of a tile is square, for the content, and a tray/gutter for information. */
  grid-template-columns: repeat(3, 1fr);
  grid-template-rows: repeat(3, 1fr) minmax(0, 0.75fr); /*<1>*/
  width: 100%;

  &:hover,
  &:focus-within {
    /* The tile is interactable. */
    background-color: rgba(0, 0, 0, 0.2);
    border-bottom: 0.25rem solid var(--palette-accent);
    box-sizing: border-box; /*<2>*/
  }

  :focus-visible {
    /* We use custom fx to denote it is focused/interactable */
    outline: none;
  }

  p {
    align-content: center;
    grid-column: 1/4;
    grid-row: 4;
    margin: 0;
    overflow: auto; /*<1>*/
    padding: 0.5rem;
    text-wrap: wrap;
  }

  button {
    background-color: transparent;
    border: none;
    cursor: pointer;

    i {
      align-content: center;
      aspect-ratio: 1/1;
      background-color: var(--palette-accent);
      border-radius: 100%;
      font-size: 1.5rem;
      text-align: center;
      width: 100%;
    }
  }

  /* <1>:
     - https://stackoverflow.com/a/52861514
     - https://stackoverflow.com/a/43312314

     When the screen area is too small, or the label requires more space than available in its position in the last row,
     the grid will expand its minimum dimensions to fit the label - we don't really want that.

     The label should overflow and not break the tiling layout.
     */

  /*  <2>:

     Include the border in the tile size calculation to prevent it from growing, and causing the grid row to grow
     when a border is added.
     */
}

div.control-bar {
  background: var(--palette-bg-panel);
  display: flex;
  flex-shrink: 0; /* <1> */
  height: 3rem;

  input {
    background-color: var(--palette-bg-content);
    border: none;
    border-radius: 0;
    color: var(--palette-text);
    margin-left: auto;
    padding-left: 1.5rem;
    width: 30%;
  }

  button {
    aspect-ratio: 1/1;
    background-color: var(--palette-bg-content);
    border: 0.5rem solid var(--palette-bg-panel);
    border-radius: 0;
    box-sizing: border-box;
    color: var(--palette-text);

    &:hover {
      cursor: pointer;
    }

    &.highlight {
      border-bottom-color: var(--palette-accent);
    }

    &:hover,
    &.highlight {
      color: var(--palette-accent);
    }
  }
}

form.modal {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;

  h2 {
    border-bottom: var(--palette-text);
    border-bottom-style: solid;
    margin-top: 0;
  }

  input {
    background: var(--palette-bg-page);
    border: none;
    border-radius: 0;
    color: var(--palette-text);
    height: 2rem;
  }

  button {
    background: var(--palette-bg-page);
    border: 0;
    border-radius: 0;
    color: var(--palette-text);
    margin-top: 2rem;
    padding: 1rem;
  }

  @media screen and (orientation: portrait) {
    top: 25%; /*<1>*/
    /* <1>
                    When on mobile, any selection for inputs will open the keyboard. As this takes up the bottom portion of the
                    screen we shift the modal up higher so it can still be in view.
                    */
  }
}

img.adaptive-filter {
  @media (prefers-color-scheme: dark) {
    /* Lightens colours (mainly for solid black icon images) during dark theme. */
    filter: invert(60%);
  }
}
